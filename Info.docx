/ccp-simulator/
├── index.html                # Main launcher page with controls to simulate events
├── README.md                 # Project documentation
└── src/
    ├── css/
    │   ├── theme.css         # CSS variables (colors, fonts, spacing) for pixel-perfect design
    │   └── main.css          # All component, layout, and state-specific styles
    ├── js/
    │   ├── app.js            # Main application logic, event listeners, and bootstrapping
    │   ├── ui.js             # Renders all UI components and handles DOM manipulation
    │   ├── state.js          # The "brain": manages the CCP state machine and all call data
    │   ├── data.js           # Handles loading and querying the biller database
    │   └── audio.js          # Manages loading and playback of audio clips
    └── assets/
        ├── data/
        │   ├── billers.json  # Database of all billers, their numbers, and metadata
        │   └── scenarios.json # Pre-defined IVR call scenarios
        └── audio/
            ├── biller_a/
            │   ├── welcome.mp3
            │   └── payment_options.mp3
            └── ui_sounds/
                ├── incoming_call.mp3
                └── hold.mp3




CCP Development Rules
Scope: These rules apply to all code, styles, assets, data, and demos for the CCP project. Treat them as the canonical laws — breaking them requires a documented exception and a code review approval.

The Board — global architecture & state (single source of truth)

Rule 1 — Single Board (appState)
Rule: appState is the only source of truth for UI and behavior. All UI must be derived from it.
Why: Prevents inconsistent UI-state and race conditions.
Enforce: Lint rule + code review: no direct DOM writes to reflect business state (except logs & timer span updates).

Rule 2 — Immutable Moves
Rule: State transitions are pure functions that return a new state slice; mutating helpers must be centralized.
Why: Predictability & easier testing.
Enforce: Unit tests for transitions; peer review.

Rule 3 — Canonical State Shape
Rule: appState must follow the documented schema (calls[], agentStatus, activePanel, isInACW, etc.). Fields must not be added ad-hoc.
Why: Prevents data drift and simplifies render code.
Enforce: Schema validation on load (simple assert) and CI static checks.

The Pieces — call objects, timers, audio, billers

Rule 4 — Call Objects Are Self-Contained
Rule: Each call object: { id, phoneNumberNormalized, status, startTime, timerIntervalId, metadata }. Timers stored only here.
Why: Easy cleanup and predictable lifecycle.
Enforce: Linter test and unit tests.

Rule 5 — No Orphan Timers
Rule: Always clear timerIntervalId when removing a call or closing CCP.
Why: Avoid leaks and zombie timers.
Enforce: On dropCall / leaveCall / onclose always assert !call.timerIntervalId.

Rule 6 — Audio Manifest & Naming
Rule: All audio files are listed in audio/manifest.json and follow <billerId>__<clipType>__<lang>.mp3. No other files used at runtime.
Why: Predictable preload and easy bundling.
Enforce: Build script validates manifest vs filesystem.

Rule 7 — Lazy & Explicit Audio Loading
Rule: UI never auto-loads the entire audio dir. Preload only UI sounds; others are lazy-loaded after a defined explicit trigger or on scenario load.
Why: Memory/performance control.
Enforce: Code review and audio manager API auditing.

The Moves — events & state transitions

Rule 8 — Finite State Machine
Rule: Implement and follow a FSM: IDLE → INCOMING → CONNECTED_SINGLE → CONNECTED_MULTI → CONFERENCE → ACW → IDLE. Transitions must be explicit, named actions.
Why: Deterministic flows and easier tests.
Enforce: Unit tests for each transition and invalid-transition rejection.

Rule 9 — Canonical Event Names
Rule: Use exact event names: INCOMING, ACCEPT, REJECT, ADD_SECOND, SWAP, JOIN, DROP, LEAVE, ACW_START, ACW_END. Payload shapes are documented.
Why: Predictable logging & automation.
Enforce: Event dispatcher verifies names/payload schema.

Rule 10 — Atomic Moves
Rule: Each action must complete one logical change only (no multi-effect monoliths). If more is required, chain actions in sequence with clearly logged intermediate states.
Why: Easier rollback & debugging.
Enforce: Code review & unit tests.

The UI — rendering rules & DOM safety

Rule 11 — Doc-Correct Element Creation
Rule: When rendering into a popup doc, use doc.createElement, doc.getElementById, etc. Never create nodes in opener document and append to popup.
Why: Cross-document DOM creation is brittle and causes odd bugs.
Enforce: Automated grep check for document.createElement usage in ccp-ui files — should be doc.createElement.

Rule 12 — No innerHTML for Dynamic Data
Rule: Use textContent or sanitized insertion for any dynamic/user data. innerHTML only for vetted static templates.
Why: Prevent XSS and accidental markup loss.
Enforce: Lint rule disallowing innerHTML except in whitelisted files.

Rule 13 — Idempotent Rendering
Rule: renderCCP() must be safe to call repeatedly — no duplicate event handlers or element duplication. All event binding done once in initializeCCPEvents().
Why: Avoid listener duplication and memory leaks.
Enforce: Tests that call renderCCP() many times assert a single set of listeners (or use a guard pattern).

Rule 14 — Timer DOM updates must preserve structure
Rule: Timer updates must update only the nested <span> text, not the container innerHTML or textContent, preserving icons and structure.
Why: Keeps icons intact.
Enforce: Code review and unit test that ensures icons remain after timer tick.

Rule 15 — CSS Tokens only
Rule: Colors, spacing, radii in theme.css only. No magic numbers in components. Visual changes must be done by updating tokens.
Why: Ensures pixel consistency & easy theming.
Enforce: Grep check for hex codes in JS/HTML.

The Referee — logging, audits, and tests

Rule 16 — Structured Logs
Rule: logMessage(type, details, meta) stores structured JSON in memory and renders a safe textual row in launcher and in-CCP log. Provide downloadLogs() that exports JSON.
Why: Auditable demo trails & debugging.
Enforce: Unit test that checks log array length and JSON integrity after simulated flows.

Rule 17 — Tests for Moves
Rule: For every new behavior add at least one scenario test (scripted sequence of events) asserting final appState and key DOM bits.
Why: Prevent regressions in flows.
Enforce: CI gate requiring scenario tests to pass.

Rule 18 — Visual Regression Snapshots
Rule: Capture screenshots of critical states (incoming, connected single, multi-call, conference, acw) and store them. Any visual token changes require updating snapshot.
Why: Pixel fidelity guarantees for demos.
Enforce: PR checks include updated images or acceptance note.

The Clock — timing & cleanup

Rule 19 — Timers use well-defined granularity
Rule: Use 1s timer for display, but compute elapsed from startTime (Date.now()) on each tick — do not accumulate via increment.
Why: Avoid drift and ensure accuracy after pauses.
Enforce: Unit test comparing formatted timer vs expected after simulated time.

Rule 20 — Cleanup on Close
Rule: On popup beforeunload and on explicit leaveCall, clear all timers, stop audio, and reset appState to baseline. Launcher must verify popup closure and do a final cleanup.
Why: No leaks, consistent next launch.
Enforce: Integration test that simulates close and asserts zero active timers.

The Database — biller & IVR rules

Rule 21 — Deterministic Lookup Priority
Rule: Lookup order: exact callerNumber → dialedNumber → normalized prefix (longest-match) → area-code suggestion. Always return confidence.
Why: Predictable biller identification.
Enforce: Unit tests for lookup cases; must provide confidence score.

Rule 22 — Normalized Phone Canonicalization
Rule: Single function normalizePhone(number) used everywhere. Store and index normalized numbers only.
Why: Consistent matches across formats.
Enforce: Grep check for other normalization implementations.

Rule 23 — IVR payload immutable snapshot
Rule: IVR payload attached to call metadata must be a shallow-frozen object snapshot { selections:[], dtmf:'', menuPath:'' }. Do not mutate it later.
Why: Historical accuracy & reproducible ACW.
Enforce: Use Object.freeze on payload when attaching.

The Pieces’ Moves — UX & accessibility

Rule 24 — Controls reflect state
Rule: Enable/disable controls strictly by appState — e.g., join enabled only when calls.length >= 2 && !isConferenced. UI must never “lie” about availability.
Why: Avoid bad user actions in demos.
Enforce: Unit tests and runtime assertions in render functions.

Rule 25 — Keyboard & ARIA
Rule: All interactive elements keyboard-focusable and have ARIA labels; overlays handle ESC to close. Use aria-live for timers/incoming announcements.
Why: Accessibility and demo robustness.
Enforce: A11y scan and manual keyboard tests.

The Release — versioning, demo branches, and assets

Rule 26 — Demo Branch Freeze
Rule: For any demo-ready build, create a demo/vX.Y snapshot branch and do not change it without bumping vX.Y and updating visual snapshots.
Why: Reproducible demos for stakeholders.
Enforce: Git workflow & PR policy.

Rule 27 — Assets must be bundled or have fallback
Rule: External CDNs optional only; include local fallback copies (icons, fonts, audio). Demo must be runnable offline if assets/ present.
Why: Corporate demos often block external network.
Enforce: Preflight script checks for all referenced assets and warns if remote-only.

The Arbitration — exceptions, audits, and traceability

Rule 28 — Exceptions require signed doc
Rule: Any rule exception must be recorded in EXCEPTIONS.md with rationale, approver, and expiry. Temporary exceptions auto-review after 2 weeks.
Why: Accountability.
Enforce: PR template requires EXCEPTIONS.md entry if any rule is broken.

Rule 29 — Traceable Events
Rule: All user-visible transitions must log one structured event with timestamp, actor, and actionId. These logs are downloadable and form part of acceptance criteria.
Why: Post-demo audit & debugging.
Enforce: Logger middleware ensures event emission.

Rule 30 — No silent failures
Rule: Any runtime error in CCP or loading assets must surface a user-friendly error in launcher log and optionally the CCP UI (fallback state). Silent console-only errors are not acceptable.
Why: Demo integrity and easier troubleshooting.
Enforce: Global error handler that logs and shows banner.
Quick Reference — "Chessboard" mnemonics
Board = appState (single source).
Pieces = Calls (self-contained objects).
Moves = Events (named actions).
Clock = Timers on call objects, derived from startTime.
Referee = Logger + unit tests + CI gates + demos branch freeze.
Rules = This list — exceptions documented.
Final: Enforcement Checklist (use pre-commit + CI)
 Lint checks (no raw innerHTML, doc.createElement usage, token usage)
 Unit tests for all FSM transitions
 Audio manifest validation script
 Visual snapshots for 5 critical states
 Demo branch & EXCEPTIONS.md presence for any rule break
If you want, I’ll now convert this into:
a compact printable rules cheat-sheet (single-page), or
produce pre-commit hook scripts + simple lint rules (grep-based) that enforce several of these automatically (e.g., forbid innerHTML, check document.createElement usage, validate audio manifest).
